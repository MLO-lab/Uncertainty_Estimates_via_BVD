import os
import torch
import torch.nn as nn
import torch.optim as optim
import torch.utils.data as data
import torchvision

from IPython.display import HTML, display, set_matplotlib_formats
from PIL import Image
from pytorch_lightning.callbacks import LearningRateMonitor, ModelCheckpoint
from torchvision import transforms
from torchvision.datasets import CIFAR10

import torch.nn.functional as F
import pandas as pd
from tqdm.notebook import tqdm
from copy import deepcopy


def BI_LSE(zs, axis=0):
    # assume classes are in the last axis
    class_axis = len(zs.shape)-1
    # we pivot on first logit entry
    zs = zs - zs[:,:,0:1]
    E_of_LSE = zs.logsumexp(axis=class_axis).mean(axis)
    LSE_of_E = zs.mean(axis).logsumexp(axis=class_axis-1)
    return E_of_LSE - LSE_of_E

def inner_product(a, b):
    ''' batch wise inner product of last axis in a and b'''
    n_size, n_classes = a.shape
    return torch.bmm(a.view(n_size, 1, n_classes), b.view(n_size, n_classes, 1)).squeeze(-1).squeeze(-1)

def d_LSE(a, b):
    '''
    bregman divergence generated by G = LSE
    d_G (a, b) = G(a) - G(b) - < grad G(b), a - b >
    '''
    # assume classes are in the last axis
    # we pivot on first logit entry
    red_a = a - a[:,0:1]
    red_b = b - b[:,0:1]
    G_of_a = red_a.logsumexp(axis=1)
    G_of_b = red_b.logsumexp(axis=1)
    grad_G_of_b = b.softmax(axis=1)
    return G_of_a - G_of_b - inner_product(grad_G_of_b, red_a - red_b)


class BI_thresh_acc_TTA:
    def __init__(self, model, val_loaders, qs, n_batches=None, n_ens=10, device='cpu', img_size=224):
        self.model = model
        self.img_size = img_size
        self.val_loaders = val_loaders
        self.qs = qs
        self.n_batches = n_batches
        self.device = device
        self.n_ens = n_ens
        
        # we compute the BI quantiles on the val set and perform thresholding on the test set
        model.to(device=device)
        val_ens_BIs = []
        iters = val_loaders if len(val_loaders)==1 else tqdm(val_loaders, desc='Loader')
        for val_loader in iters:
            for xs, ys in tqdm(val_loader, desc='Val set', leave=False):
                xs = xs.to(device=device)
                ys = ys.to(device=device)
                preds = model(xs)
                ens_preds = self.get_TTA_preds(xs)
                val_ens_BIs += [BI_LSE(ens_preds, axis=0)]
        self.val_ens_BIs = torch.cat(val_ens_BIs)
        
    def get_TTA_preds(self, xs):
        TTA_transform = transforms.Compose([
            transforms.RandomHorizontalFlip(),
            transforms.RandomResizedCrop(self.img_size, scale=(0.8, 1.0), ratio=(0.9, 1.1)),
        ])
        results = []
        for _ in range(self.n_ens):
            results += [self.model(TTA_transform(xs)).detach().unsqueeze(0)]
        return torch.cat(results)

    def run(self, test_loaders):

        test_ens_BIs = []
        test_preds = []
        test_ys = []
        iters = test_loaders if len(test_loaders)==1 else tqdm(test_loaders, desc='Loader')
        for test_loader in iters:
            for xs, ys in tqdm(test_loader, desc='Test set', leave=False):
                xs = xs.to(device=self.device)
                ys = ys.to(device=self.device)
                preds = self.model.to(device=self.device)(xs).detach()
                ens_preds = self.get_TTA_preds(xs)
                test_ens_BIs += [BI_LSE(ens_preds, axis=0)]
                test_preds += [preds]
                test_ys += [ys]

        test_ens_BIs = torch.cat(test_ens_BIs)
        test_preds = torch.cat(test_preds)
        test_ys = torch.cat(test_ys)

        results = {'BI Quantile': [], 'Accuracy': [], 'Classif perc': []}
        for q in self.qs:
            mask = test_ens_BIs <= torch.quantile(self.val_ens_BIs, q)
            sub_preds = test_preds[mask]
            sub_ys = test_ys[mask]
            results['Accuracy'].append(sub_preds.argmax(-1).eq(sub_ys).float().mean().item())
            results['BI Quantile'].append(q)
            results['Classif perc'].append(mask.float().mean().item())

        return pd.DataFrame(results)
    
    
class BI_thresh_acc_DE:
    def __init__(self, models, val_loaders, qs, n_batches=None, device='cpu'):
        self.models = models
        self.val_loaders = val_loaders
        self.qs = qs
        self.n_batches = n_batches
        self.device = device
        
        # we compute the BI quantiles on the val set and perform thresholding on the test set
        val_ens_BIs = []
        iters = val_loaders if len(val_loaders)==1 else tqdm(val_loaders, desc='Loader')
        for val_loader in iters:
            for xs, ys in tqdm(val_loader, desc='Val set', leave=False):
                xs = xs.to(device=device)
                ys = ys.to(device=device)
                preds = models[0].to(device=device)(xs).detach()
                ens_preds = []
                for m in models:
                    ens_preds += [m.to(device=device)(xs).unsqueeze(0).detach()]
                ens_preds = torch.cat(ens_preds)
                val_ens_BIs += [BI_LSE(ens_preds, axis=0)]
        self.val_ens_BIs = torch.cat(val_ens_BIs)

    def run(self, test_loaders):

        test_ens_BIs = []
        test_preds = []
        test_ys = []
        iters = test_loaders if len(test_loaders)==1 else tqdm(test_loaders, desc='Loader')
        for test_loader in iters:
            for xs, ys in tqdm(test_loader, desc='Test set', leave=False):
                xs = xs.to(device=self.device)
                ys = ys.to(device=self.device)
                preds = self.models[0].to(device=self.device)(xs).detach()
                ens_preds = []
                for m in self.models:
                    ens_preds += [m.to(device=self.device)(xs).unsqueeze(0).detach()]
                ens_preds = torch.cat(ens_preds)
                test_ens_BIs += [BI_LSE(ens_preds, axis=0)]
                test_preds += [preds]
                test_ys += [ys]

        test_ens_BIs = torch.cat(test_ens_BIs)
        test_preds = torch.cat(test_preds)
        test_ys = torch.cat(test_ys)

        results = {'BI Quantile': [], 'Accuracy': [], 'Classif perc': []}
        for q in self.qs:
            mask = test_ens_BIs <= torch.quantile(self.val_ens_BIs, q)
            sub_preds = test_preds[mask]
            sub_ys = test_ys[mask]
            results['Accuracy'].append(sub_preds.argmax(-1).eq(sub_ys).float().mean().item())
            results['BI Quantile'].append(q)
            results['Classif perc'].append(mask.float().mean().item())

        return pd.DataFrame(results)
    

class Conf_thresh_acc:
    def __init__(self, model, val_loaders, qs, n_batches=None, device='cpu'):
        self.model = model
        self.val_loaders = val_loaders
        self.qs = qs
        self.n_batches = n_batches
        self.device = device

        # we compute the quantiles on the val set and perform thresholding on the test set
        val_Confs = []
        iters = val_loaders if len(val_loaders)==1 else tqdm(val_loaders, desc='Loader')
        for val_loader in iters:
            for xs, ys in tqdm(val_loader, desc='Val set', leave=False):
                xs = xs.to(device=device)
                ys = ys.to(device=device)
                preds = self.model.to(device=device)(xs).detach()
                val_Confs += [preds.softmax(-1).max(-1).values]
        self.val_Confs = torch.cat(val_Confs)

    def run(self, test_loaders):

        test_preds = []
        test_ys = []
        iters = test_loaders if len(test_loaders)==1 else tqdm(test_loaders, desc='Loader')
        for test_loader in iters:
            for xs, ys in tqdm(test_loader, desc='Test set', leave=False):
                xs = xs.to(device=self.device)
                ys = ys.to(device=self.device)
                preds = self.model.to(device=self.device)(xs).detach()
                test_preds += [preds]
                test_ys += [ys]

        test_preds = torch.cat(test_preds)
        test_ys = torch.cat(test_ys)

        results = {'Conf Quantile': [], 'Accuracy': [], 'Classif perc': []}
        for q in self.qs:
            mask = test_preds.softmax(-1).max(-1).values >= torch.quantile(self.val_Confs, q)
            sub_preds = test_preds[mask]
            sub_ys = test_ys[mask]
            results['Accuracy'].append(sub_preds.argmax(-1).eq(sub_ys).float().mean().item())
            results['Conf Quantile'].append(q.item())
            results['Classif perc'].append(mask.float().mean().item())

        return pd.DataFrame(results)
    
    
class BI_thresh_acc_MCD:
    def __init__(self, model, val_loaders, qs, n_batches=None, n_ens=10, device='cpu', img_size=224):
        self.model = model
        self.img_size = img_size
        self.val_loaders = val_loaders
        self.qs = qs
        self.n_batches = n_batches
        self.device = device
        self.n_ens = n_ens
        self.params = []
        for param in self.model.parameters():
            self.params += [deepcopy(param)]

        
        # we compute the BI quantiles on the val set and perform thresholding on the test set
        model.to(device=device)
        val_ens_BIs = []
        iters = val_loaders if len(val_loaders)==1 else tqdm(val_loaders, desc='Loader')
        for val_loader in iters:
            for xs, ys in tqdm(val_loader, desc='Val set', leave=False):
                xs = xs.to(device=device)
                ys = ys.to(device=device)
                preds = model(xs)
                ens_preds = self.get_MCD_preds(xs)
                val_ens_BIs += [BI_LSE(ens_preds, axis=0)]
        self.val_ens_BIs = torch.cat(val_ens_BIs)
        
    def get_MCD_preds(self, xs):
        results = []
        for _ in range(self.n_ens):
            for param in self.model.parameters():
                param = F.dropout(param, p=0.5)
            results += [self.model(xs).detach().unsqueeze(0)]
            for param_old, param in zip(self.params, self.model.parameters()):
                param = param_old
        return torch.cat(results)

    def run(self, test_loaders):

        test_ens_BIs = []
        test_preds = []
        test_ys = []
        iters = test_loaders if len(test_loaders)==1 else tqdm(test_loaders, desc='Loader')
        for test_loader in iters:
            for xs, ys in tqdm(test_loader, desc='Test set', leave=False):
                xs = xs.to(device=self.device)
                ys = ys.to(device=self.device)
                preds = self.model.to(device=self.device)(xs).detach()
                ens_preds = self.get_MCD_preds(xs)
                test_ens_BIs += [BI_LSE(ens_preds, axis=0)]
                test_preds += [preds]
                test_ys += [ys]

        test_ens_BIs = torch.cat(test_ens_BIs)
        test_preds = torch.cat(test_preds)
        test_ys = torch.cat(test_ys)

        results = {'BI Quantile': [], 'Accuracy': [], 'Classif perc': []}
        for q in self.qs:
            mask = test_ens_BIs <= torch.quantile(self.val_ens_BIs, q)
            sub_preds = test_preds[mask]
            sub_ys = test_ys[mask]
            results['Accuracy'].append(sub_preds.argmax(-1).eq(sub_ys).float().mean().item())
            results['BI Quantile'].append(q)
            results['Classif perc'].append(mask.float().mean().item())

        return pd.DataFrame(results)
    
    
class BI_thresh_DE:
    def __init__(self, model, ensemble, val_loaders, qs, n_batches=None, device='cpu'):
        self.model = model
        self.ensemble = ensemble
        self.val_loaders = val_loaders
        self.qs = qs
        self.n_batches = n_batches
        self.device = device
        
        # we compute the BI quantiles on the val set and perform thresholding on the test set
        val_ens_BIs = []
        iters = val_loaders if len(val_loaders)==1 else tqdm(val_loaders, desc='Loader')
        for val_loader in iters:
            for xs, ys in tqdm(val_loader, desc='Val set', leave=False):
                xs = xs.to(device=device)
                ys = ys.to(device=device)
                preds = model.to(device=device)(xs).detach()
                ens_preds = []
                for m in ensemble:
                    ens_preds += [m.to(device=device)(xs).unsqueeze(0).detach()]
                ens_preds = torch.cat(ens_preds)
                val_ens_BIs += [BI_LSE(ens_preds, axis=0)]
        self.val_ens_BIs = torch.cat(val_ens_BIs)

    def run(self, test_loaders):

        test_ens_BIs = []
        test_preds = []
        test_ys = []
        iters = test_loaders if len(test_loaders)==1 else tqdm(test_loaders, desc='Loader')
        for test_loader in iters:
            for xs, ys in tqdm(test_loader, desc='Test set', leave=False):
                xs = xs.to(device=self.device)
                ys = ys.to(device=self.device)
                preds = self.model.to(device=self.device)(xs).detach()
                ens_preds = []
                for m in self.ensemble:
                    ens_preds += [m.to(device=self.device)(xs).unsqueeze(0).detach()]
                ens_preds = torch.cat(ens_preds)
                test_ens_BIs += [BI_LSE(ens_preds, axis=0)]
                test_preds += [preds]
                test_ys += [ys]

        test_ens_BIs = torch.cat(test_ens_BIs)
        test_preds = torch.cat(test_preds)
        test_ys = torch.cat(test_ys)

        results = {'BI Quantile': [], 'Accuracy': [], 'Classif perc': [], 'NLL': []}
        for q in self.qs:
            mask = test_ens_BIs <= torch.quantile(self.val_ens_BIs, q)
            sub_preds = test_preds[mask]
            sub_ys = test_ys[mask]
            results['Accuracy'].append(sub_preds.argmax(-1).eq(sub_ys).float().mean().item())
            results['NLL'].append(F.cross_entropy(sub_preds, sub_ys).item())
            results['BI Quantile'].append(q)
            results['Classif perc'].append(mask.float().mean().item())

        return pd.DataFrame(results)
    

class Conf_thresh:
    def __init__(self, model, val_loaders, qs, n_batches=None, device='cpu'):
        self.model = model
        self.val_loaders = val_loaders
        self.qs = qs
        self.n_batches = n_batches
        self.device = device

        # we compute the quantiles on the val set and perform thresholding on the test set
        val_Confs = []
        iters = val_loaders if len(val_loaders)==1 else tqdm(val_loaders, desc='Loader')
        for val_loader in iters:
            for xs, ys in tqdm(val_loader, desc='Val set', leave=False):
                xs = xs.to(device=device)
                ys = ys.to(device=device)
                preds = self.model.to(device=device)(xs).detach()
                val_Confs += [preds.softmax(-1).max(-1).values]
        self.val_Confs = torch.cat(val_Confs)

    def run(self, test_loaders):

        test_preds = []
        test_ys = []
        iters = test_loaders if len(test_loaders)==1 else tqdm(test_loaders, desc='Loader')
        for test_loader in iters:
            for xs, ys in tqdm(test_loader, desc='Test set', leave=False):
                xs = xs.to(device=self.device)
                ys = ys.to(device=self.device)
                preds = self.model.to(device=self.device)(xs).detach()
                test_preds += [preds]
                test_ys += [ys]

        test_preds = torch.cat(test_preds)
        test_ys = torch.cat(test_ys)

        results = {'Conf Quantile': [], 'Accuracy': [], 'Classif perc': [], 'NLL': []}
        for q in self.qs:
            mask = test_preds.softmax(-1).max(-1).values >= torch.quantile(self.val_Confs, q)
            sub_preds = test_preds[mask]
            sub_ys = test_ys[mask]
            results['Accuracy'].append(sub_preds.argmax(-1).eq(sub_ys).float().mean().item())
            results['NLL'].append(F.cross_entropy(sub_preds, sub_ys).item())
            results['Conf Quantile'].append(q.item())
            results['Classif perc'].append(mask.float().mean().item())

        return pd.DataFrame(results)
    
    
